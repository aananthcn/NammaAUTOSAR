#
# Created on Mon Dec 19 2022 6:32:42 PM
#
# The MIT License (MIT)
# Copyright (c) 2022 Aananth C N
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software
# and associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial
# portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
import os

# import arxml.lin.arxml_lin as arxml_lin
import utils.search as search

# Temporary work-around
import gui.mcu.uc_cgen as uc_cgen


LinGeneralCfgType_str = "\n\ntypedef struct {\n\
    uint8 lin_index;\n\
    boolean lin_dev_error_detect;\n\
    boolean lin_version_info_api;\n\
    uint16 lin_timeout_sec;\n\
} LinGeneralCfgType;\n\
\n"

LinNodeType_str = "\ntypedef enum {\n\
    MASTER,\n\
    SLAVE\n\
} LinNodeType;\n\
\n"

LinChannelCfgType_str = "\ntypedef struct {\n\
    uint16 lin_chan_id;\n\
    uint16 lin_chan_baudrate;\n\
    LinNodeType lin_node_type;\n\
    boolean lin_wakeup_support;\n\
    const char* lin_wakeup_source;\n\
    const char* lin_clock_ref;\n\
} LinChannelCfgType;\n\
\n"

Lin_ConfigType_str = "\ntypedef struct {\n\
    const LinGeneralCfgType general;\n\
    const LinChannelCfgType chn_cfg;\n\
} Lin_ConfigType;\n\
"



def generate_sourcefile(lin_src_path, lin_configs):
    cf = open(lin_src_path+"/cfg/Lin_cfg.c", "w")
    cf.write("#include <stddef.h>\n")
    cf.write("#include <Lin_cfg.h>\n\n\n")
    cf.write("// This file is autogenerated, any hand modifications will be lost!\n\n")

    cf.write("\n\nconst Lin_ConfigType LinConfigs[LIN_DRIVER_MAX_CHANNEL] = {\n")
    for i, cfg in enumerate(lin_configs):
        # print(cfg.datavar)
        cf.write("\t{\n")
        cf.write("\t\t/* Lin channel - "+str(i)+" */\n")
        cf.write("\t\t.general = {\n")
        cf.write("\t\t\t.lin_index = "+ cfg.datavar["LinGeneral"]["LinIndex"] +",\n")
        cf.write("\t\t\t.lin_dev_error_detect = "+ cfg.datavar["LinGeneral"]["LinDevErrorDetect"] +",\n")
        cf.write("\t\t\t.lin_version_info_api = "+ cfg.datavar["LinGeneral"]["LinVersionInfoApi"] +",\n")
        cf.write("\t\t\t.lin_timeout_sec = "+ cfg.datavar["LinGeneral"]["LinTimeoutDuration"] +"\n")
        cf.write("\t\t},\n")
        cf.write("\t\t.chn_cfg = {\n")
        cf.write("\t\t\t.lin_chan_id = "+ cfg.datavar["LinGlobalConfig"]["LinChannelId"] +",\n")
        cf.write("\t\t\t.lin_chan_baudrate = "+ cfg.datavar["LinGlobalConfig"]["LinChannelBaudRate"] +",\n")
        cf.write("\t\t\t.lin_node_type = "+ cfg.datavar["LinGlobalConfig"]["LinNodeType"] +",\n")
        cf.write("\t\t\t.lin_wakeup_support = "+ cfg.datavar["LinGlobalConfig"]["LinChannelWakeupSupport"] +",\n")
        cf.write("\t\t\t.lin_wakeup_source = \""+ cfg.datavar["LinGlobalConfig"]["LinChannelEcuMWakeupSource"] +"\", /* This could be wrong! */\n")
        cf.write("\t\t\t.lin_clock_ref = \""+ cfg.datavar["LinGlobalConfig"]["LinClockRef"] +"\", /* This could be wrong! */ \n")
        cf.write("\t\t}\n")
        cf.write("\t},\n")
    cf.write("};\n")

    cf.close()



def generate_headerfile(lin_src_path, lin_configs):
    hf = open(lin_src_path+"/cfg/Lin_cfg.h", "w")
    hf.write("#ifndef NAMMA_AUTOSAR_LIN_CFG_H\n")
    hf.write("#define NAMMA_AUTOSAR_LIN_CFG_H\n\n")
    hf.write("// This file is autogenerated, any hand modifications will be lost!\n\n")
    hf.write("#include <Platform_Types.h>\n\n")

    hf.write("#define LIN_DRIVER_MAX_CHANNEL    ("+str(len(lin_configs))+")\n")
    
    hf.write(LinGeneralCfgType_str)
    hf.write(LinNodeType_str)
    hf.write(LinChannelCfgType_str)
    hf.write(Lin_ConfigType_str)
    
    # External Declarations
    hf.write("\n\n\nextern const Lin_ConfigType LinConfigs[LIN_DRIVER_MAX_CHANNEL];\n")
    
    hf.write("\n\n#endif\n")
    hf.close()



def generate_code(gui, lin_configs):
    cwd = os.getcwd()
    lin_src_path = search.find_dir("Lin", cwd+"/submodules/MCAL/")
    generate_headerfile(lin_src_path, lin_configs)
    generate_sourcefile(lin_src_path, lin_configs)
    uc_cgen.create_source(gui) # calling uc_cgen.create_source() is a work-around. This will be corrected later.
    
